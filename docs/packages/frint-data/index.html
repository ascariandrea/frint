<!DOCTYPE html>
<html>
  <head>
    <title>frint-data | Frint</title>
  </head>

  <body>
    <nav class="nav">
      <div class="container">
        <div class="nav-left">
  <a href="/" class="nav-item brand">
    <img alt="Frint" class="dark" src="/img/frint-logo-7a7a7a.png" />
    <img alt="Frint" class="light" src="/img/frint-logo-fff.png" />
  </a>

  <a href="/docs" class="nav-item is-tab">
    Documentation
  </a>

  <a href="/guides" class="nav-item is-tab">
    Guides
  </a>

  <a href="/repl" class="nav-item is-tab">
    REPL
  </a>

  <a href="/about" class="nav-item is-tab">
    About
  </a>
</div>

<div class="nav-right">
  <div class="field nav-item">
    <p class="control has-icon">
      <input id="doc-search-text-box" class="input" type="text" placeholder="Search...">
      <span class="icon is-small">
        <i class="fa fa-search"></i>
      </span>
    </p>
  </div>
</div>

      </div>
    </nav>

    <section class="section">
      <div class="container">
        <div class="columns">
          <div class="column is-one-quarter">
            <div class="menu-container docs">
  <aside class="menu docs">
    <p class="menu-label">
      Quickstart
    </p>

    <ul class="menu-list">
      <li><a href="/guides/hello-world">Hello World</a></li>
    </ul>

    <p class="menu-label">
      Packages
    </p>

    <ul class="menu-list">
      <li><a href="/docs/packages/frint">frint</a></li>
      <li><a href="/docs/packages/frint-store">frint-store</a></li>
      <li><a href="/docs/packages/frint-data">frint-data</a></li>
      <li><a href="/docs/packages/frint-react">frint-react</a></li>
      <li><a href="/docs/packages/frint-react-server">frint-react-server</a></li>
      <li><a href="/docs/packages/frint-router">frint-router</a></li>
      <li><a href="/docs/packages/frint-router-react">frint-router-react</a></li>
      <li><a href="/docs/packages/frint-cli">frint-cli</a></li>
      <li><a href="/docs/packages/frint-config">frint-config</a></li>
      <li><a href="/docs/packages/frint-component-utils">frint-component-utils</a></li>
      <li><a href="/docs/packages/frint-component-handlers">frint-component-handlers</a></li>
      <li><a href="/docs/packages/frint-test-utils">frint-test-utils</a></li>
      <li><a href="/docs/packages/frint-compat">frint-compat</a></li>
    </ul>

    <p class="menu-label">
      Migration
    </p>

    <ul class="menu-list">
      <li><a href="/docs/migration/v1">Migrating to v1.x</a></li>
      <li><a href="/docs/migration/v2">Migrating to v2.x</a></li>
      <li><a href="/docs/migration/v3">Migrating to v3.x</a></li>
    </ul>

    <p class="menu-label">
      Contributing
    </p>

    <ul class="menu-list">
      <li><a href="/docs/contributing/maintainers">Maintainers guide</a></li>
    </ul>

    <p class="menu-label">
      Project
    </p>

    <ul class="menu-list">
      <li><a href="/docs/changelog">Changelog</a></li>
    </ul>
  </aside>
</div>

          </div>

          <div class="column content">
            <h1 id="frint-data">frint-data</h1>
<p><a href="https://www.npmjs.com/package/frint-data"><img src="https://img.shields.io/npm/v/frint-data.svg" alt="npm"></a></p>
<blockquote>
<p>Reactive data modelling package for Frint</p>
</blockquote>
<!-- MarkdownTOC autolink=true bracket=round -->
<ul>
<li><a href="#guide">Guide</a><ul>
<li><a href="#installation">Installation</a></li>
<li><a href="#terminologies">Terminologies</a></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#types">Types</a></li>
<li><a href="#models">Models</a></li>
<li><a href="#collections">Collections</a></li>
<li><a href="#embedding">Embedding</a></li>
<li><a href="#note">Note</a></li>
</ul>
</li>
<li><a href="#api">API</a><ul>
<li><a href="#types-1">Types</a></li>
<li><a href="#createmodel">createModel</a></li>
<li><a href="#createcollection">createCollection</a></li>
<li><a href="#model">Model</a></li>
<li><a href="#collection">Collection</a></li>
<li><a href="#reduce">reduce</a></li>
<li><a href="#ismodel">isModel</a></li>
<li><a href="#iscollection">isCollection</a></li>
<li><a href="#typeserror">TypesError</a></li>
<li><a href="#methoderror">MethodError</a></li>
<li><a href="#collectionerror">CollectionError</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<hr>
<h1 id="guide">Guide</h1>
<h2 id="installation">Installation</h2>
<p>With <a href="https://www.npmjs.com/">npm</a>:</p>
<pre><code>$ npm install --save frint-data
</code></pre><p>Via <a href="https://unpkg.com">unpkg</a> CDN:</p>
<pre><code class="lang-html">&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.0.1/Rx.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/frint-data@latest/dist/frint-data.min.js&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  // available as `window.FrintData`
&lt;/script&gt;
</code></pre>
<h2 id="terminologies">Terminologies</h2>
<ul>
<li><code>Model</code>: Object-like data structures</li>
<li><code>Collection</code>: Array-like data structures</li>
<li><code>Schema</code>: The structure of a Model</li>
<li><code>Type</code>: Type of individual keys in a Model&#39;s Schema</li>
</ul>
<h2 id="usage">Usage</h2>
<p>Let&#39;s first import the dependencies:</p>
<pre><code class="lang-js">import { Types, createModel, createCollection } from &#39;frint-data&#39;;
</code></pre>
<h3 id="define-model">Define Model</h3>
<pre><code class="lang-js">// Individual Todo items can be Models
const Todo = createModel({
  // schema
  schema: {
    title: Types.string, // or, Types.string.isRequired
    completed: Types.bool, // or, Types.bool.defaults(false)
  },

  // custom methods
  setTitle(newTitle) {
    this.title = newTitle;
  },
});
</code></pre>
<h3 id="define-a-collection">Define a Collection</h3>
<pre><code class="lang-js">// a group of Todo models can be put in a Todos collection
const Todos = createCollection({
  model: Todo,
});
</code></pre>
<h3 id="intantiate-classes">Intantiate classes</h3>
<pre><code class="lang-js">// model
const todo = new Todo({
  title: &#39;First task&#39;,
  completed: false,
});

// collection
const todos = new Todos();
todos.push(todo);
</code></pre>
<h3 id="model-usage">Model usage</h3>
<pre><code class="lang-js">// access properties
console.log(todo.title); // `First task`

// properties are immutable
todo.title = &#39;First task title changed&#39;;
console.log(todo.title); // still `First task`

// mutate them via methods only
todo.setTitle(&#39;First task [updated]&#39;);
console.log(todo.title); // `First task [updated]`
</code></pre>
<h3 id="collection-usage">Collection usage</h3>
<pre><code class="lang-js">// lets push the model to collection
todos.push(todo);
console.log(todos.length); // `1`

todos.push(new Todo({
  title: &#39;My second task&#39;,
  completed: false
}));
console.log(todos.length); // `2`

// let&#39;s take the last model out of the collection
const lastTodo = todos.pop();
console.log(lastTodo); // `My second task`
</code></pre>
<h3 id="observing-models-and-collections">Observing Models and Collections</h3>
<pre><code class="lang-js">// model
const todoTitle$ = todo.get$()
  .map(model =&gt; model.title);

todoTitle$.subscribe(function (title) {
  console.log(title); // will stream as the Model changes
});

// collection
todos.get$().subscribe(function (collection) {
  console.log(&#39;collection was changed&#39;);
});
</code></pre>
<h2 id="types">Types</h2>
<p>One of the main features of <code>frint-data</code> is that it is strictly based on typed values.</p>
<p>A list of type expressions are already shipped with the package and you can import them as follows:</p>
<pre><code class="lang-js">import { Types } from &#39;frint-data&#39;;
</code></pre>
<p>Some of the types include:</p>
<ul>
<li><code>Types.string</code></li>
<li><code>Types.number</code></li>
<li><code>Types.enum</code></li>
<li>...see API Reference below for more.</li>
</ul>
<h3 id="primary-types">Primary types</h3>
<p>If you want to check the type of a value that you expect to be a string:</p>
<pre><code class="lang-js">const checkIfString = Types.string;
</code></pre>
<p>Now the <code>checkIfString</code> function would return a string if a correct valid string was passed to it, otherwise it would throw a new <code>TypesError</code>.</p>
<pre><code class="lang-js">const str = checkIfString(&#39;Hello World&#39;); // returns `Hello World`

const foo = checkIfString([1, 2, 3]); // throws TypesError
</code></pre>
<h3 id="chaining-types">Chaining types</h3>
<p>Type expressions can also be chained:</p>
<pre><code class="lang-js">const checkIfString = Types.string.isRequired;

checkIfString(&#39;hello world&#39;); // returns `hello world`

checkIfString(); // throws TypesError: value is undefined
</code></pre>
<p>Available chained expressions:</p>
<ul>
<li><code>isRequired</code></li>
<li><code>defaults(defaultValue)</code></li>
</ul>
<h2 id="models">Models</h2>
<p>Models are objects that <strong>represent</strong> data. A model can hold data in the form of regular strings, booleans, and even embed other Models and Collections.</p>
<h3 id="create-a-model-class">Create a Model class</h3>
<p>When creating a Model class, we need to pass a schema (formed of <code>Types</code>):</p>
<pre><code class="lang-js">import { Types, createModel } from &#39;frint-data&#39;;

const Todo = createModel({
  schema: {
    title: Types.string.isRequired,
    completed: Types.bool.defaults(false),
  },
});
</code></pre>
<p>Here, we are creating a new Model class for Todo, and we are providing a schema to it saying <code>title</code> is a required string, and <code>completed</code> is a boolean value that defaults to <code>false</code>.</p>
<h3 id="create-a-model-instance">Create a model instance</h3>
<pre><code class="lang-js">const todo = new Todo({
  title: &#39;My new todo item&#39;
});
</code></pre>
<p>Since <code>completed</code> would default to false, we don&#39;t need to pass it during instantiation. But if we didn&#39;t provide the <code>title</code>, it would throw a new <code>TypesError</code>.</p>
<h3 id="accessing-model-properties">Accessing model properties</h3>
<p>You can get the values from your model instance just like you would do with a regular plain object:</p>
<pre><code class="lang-js">const title = todo.title; // `My new todo item`
</code></pre>
<h3 id="immutable-by-default">Immutable by default</h3>
<p>Model properties are immutable by default. And you can only change them via methods that you define while creating the Model class in the beginning.</p>
<pre><code class="lang-js">todo.title = &#39;Changing the title&#39;; // has no impact

console.log(todo.title); // still `My new todo item`
</code></pre>
<h3 id="model-methods">Model methods</h3>
<p>To change any property values, lets extend your Model class a bit more, by passing a new method in <code>createModel()</code>:</p>
<pre><code class="lang-js">const Todo = createModel({
  schema: {
    title: Types.string.isRequired,
    completed: Types.bool.defaults(false),
  },

  // custom method
  setTitle(newTitle) {
    this.title = newTitle;
  },
});
</code></pre>
<p>Now from instance level, we can change the title:</p>
<pre><code class="lang-js">todo.setTitle(&#39;Changing the title&#39;);

console.log(todo.title); // `Changing the title`
</code></pre>
<h2 id="collections">Collections</h2>
<p>Collections are <strong>arrays</strong> of Models, and to be more precise, they contain Models of a specific single class.</p>
<p>For example a <code>Todos</code> collection consisting of only <code>Todo</code> models.</p>
<h3 id="create-a-collection-class">Create a Collection class</h3>
<pre><code class="lang-js">import { createCollection } from &#39;frint-data&#39;;

const Todos = createCollection({
  model: Todo, // passing the Todo model class
});
</code></pre>
<h3 id="create-a-collection-instance">Create a collection instance</h3>
<pre><code class="lang-js">// empty instance
const todos = new Todos();

// instance with some models data
const todos = new Todos([
  { title: &#39;First task&#39; }, // will be converted to Todo instances
  { title: &#39;Second task&#39;}
]);

// instance with some model instances
const todos = new Todos([
  new Todo({ title: &#39;First task&#39; }),
  new Todo({ title: &#39;Second task&#39; })
]);
</code></pre>
<h3 id="methods">Methods</h3>
<p>You can make new methods available to your collection instances as follows:</p>
<pre><code class="lang-js">const Todos = createCollection({
  model: Todo,

  // custom method
  doSomething() {
    return true;
  },
});
</code></pre>
<p>Collection instances also come with built-in methods like <code>map</code>, <code>filter</code>, <code>reduce</code> just like <code>Array</code>. See more in API Reference.</p>
<h2 id="embedding">Embedding</h2>
<p>Models can embed other Models and Collections, and this can go as many levels deep as the data structure demands.</p>
<h3 id="embedding-models">Embedding Models</h3>
<p>Let&#39;s say we have an individual <code>Address</code> model:</p>
<pre><code class="lang-js">import { Types, createModel } from &#39;frint-data&#39;;

const Address = createModel({
  schema: {
    street: Types.string.isRequired,
    city: Types.string.isRequired,
  },
  setStreet(street) {
    this.street = street;
  },
});
</code></pre>
<p>And we also have a <code>Person</code> model:</p>
<pre><code class="lang-js">const Person = createModel({
  schema: {
    name: Types.string.isRequired,
  },
});
</code></pre>
<p>If we wish to embed <code>Address</code> model in a new schema key <code>address</code> in <code>Person</code> model, we can do:</p>
<pre><code class="lang-js">const Person = createModel({
  schema: {
    name: Types.string.isRequired,
    address: Types.model.of(Address).isRequired,
  },
});
</code></pre>
<p>Next, if we instantiate a new <code>Person</code>:</p>
<pre><code class="lang-js">const person = new Person({
  name: &#39;Sirius Black&#39;,
  address: {
    street: &#39;12 Grimmauld Place&#39;,
    city: &#39;London&#39;
  }
});

// `person` is an instance of Person
// `person.address` is an instance of Address
</code></pre>
<p>To change the street name of the address, we would access the method as:</p>
<pre><code class="lang-js">person.address.setStreet(&#39;New street name&#39;);
</code></pre>
<h3 id="embedding-collections">Embedding Collections</h3>
<p>From previous examples, we already have a <code>Person</code> model. Now let&#39;s say, a <code>Person</code> has a collection of <code>Books</code>.</p>
<p>We can define the classes as follows:</p>
<pre><code class="lang-js">import { Types, createModel, createCollection } from &#39;frint-data&#39;;

const Book = createModel({
  schema: {
    title: Types.string.isRequired,
  },
});

const Books = createCollection({
  model: Book,
});

const Person = createModel({
  schema: {
    name: Types.string.isRequired,
    books: Types.collection.of(Books),
  },
});
</code></pre>
<p>When instantiating a <code>Person</code>, we can optionally pass books data too:</p>
<pre><code class="lang-js">const person = new Person({
  name: &#39;Bathilda Bagshot&#39;,
  books: [
    { title: &#39;A History of Magic&#39; }
  ]
});

// `person` is an instance of Person
// `person.books` is an instance of Books
// `person.books.at(0)` is an instance of Book
</code></pre>
<p>You could now add more books to the list as:</p>
<pre><code class="lang-js">person.books.push(new Book({
  name: &#39;Hogwarts: A History&#39;
}));
</code></pre>
<h2 id="note">Note</h2>
<p>The API is highly inspired by <a href="https://tydel.js.org">Tydel</a>, and this package aims to be a reactive version of it using RxJS.</p>
<hr>
<h1 id="api">API</h1>
<h2 id="types">Types</h2>
<blockquote>
<p>Types</p>
</blockquote>
<p>Type expressions for your Models&#39; schema.</p>
<p>Available types:</p>
<h3 id="types-string">Types.string</h3>
<blockquote>
<p>Types.string</p>
</blockquote>
<pre><code class="lang-js">const Todo = createModel({
  schema: {
    title: Types.string
  }
});
</code></pre>
<h3 id="types-bool">Types.bool</h3>
<blockquote>
<p>Types.bool</p>
</blockquote>
<pre><code class="lang-js">const Todo = createModel({
  schema: {
    completed: Types.bool
  }
});
</code></pre>
<h3 id="types-number">Types.number</h3>
<blockquote>
<p>Types.number</p>
</blockquote>
<pre><code class="lang-js">const Person = createModel({
  schema: {
    age: Types.number
  }
});
</code></pre>
<h3 id="types-enum">Types.enum</h3>
<blockquote>
<p>Types.enum</p>
</blockquote>
<p>If you want the value to be one of the pre-defined list of values:</p>
<pre><code class="lang-js">const Book = createModel({
  schema: {
    category: Types.enum([
      &#39;history&#39;,
      &#39;fiction&#39;,
      &#39;romance&#39;
    ])
  }
});
</code></pre>
<p>And if you want the enum to be of specific types, you can use enum.of:</p>
<pre><code class="lang-js">const Book = createModel({
  schema: {
      category: Types.enum.of([
      Types.string,
      Types.number
    ])
  }
});
</code></pre>
<h3 id="types-uuid">Types.UUID</h3>
<blockquote>
<p>Types.uuid</p>
</blockquote>
<pre><code class="lang-js">const Book = createModel({
  schema: {
    id: Types.uuid
  }
});
</code></pre>
<p>Example UUID value: 27961a0e-f4e8-4eb3-bf95-c5203e1d87b9</p>
<h3 id="types-model">Types.model</h3>
<blockquote>
<p>Types.model</p>
</blockquote>
<p>Models can embed other models too:</p>
<pre><code class="lang-js">const Person = createModel({
  schema: {
    address: Types.model
  }
});
</code></pre>
<p>If you want to be more strict about which Model class can be embedded, use <code>model.of</code>:</p>
<pre><code class="lang-js">const Address = createModel({
  schema: {
    street: Types.string,
    city: Types.string
  }
});

const Person = createModel({
  schema: {
    address: Types.model.of(Address)
  }
});
</code></pre>
<h3 id="types-collection">Types.collection</h3>
<blockquote>
<p>Types.collection</p>
</blockquote>
<p>Collections can also be embedded in models:</p>
<pre><code class="lang-js">const Author = createModel({
  schema: {
    books: Types.collection
  }
});
</code></pre>
<p>If you want to be more strict about which Collection class can be embedded, use <code>collection.of</code>:</p>
<pre><code class="lang-js">const Book = createModel({
  schema: {
    title: Types.string
  }
});

const Books = createCollection({
  model: Book
});

const Author = createModel({
  schema: {
    books: Types.collection.of(Books)
  }
});
</code></pre>
<p>The following Types are available, but not recommended for use since these do not support observing them for changes. Consider embedding Models or Collections instead:</p>
<ul>
<li><code>Types.object</code></li>
<li><code>Types.array</code></li>
<li><code>Types.any</code></li>
</ul>
<h2 id="createmodel">createModel</h2>
<blockquote>
<p>createModel(options)</p>
</blockquote>
<p>Returns a <code>Model</code> class based on the schema and methods that are provided.</p>
<h3 id="arguments">Arguments</h3>
<ol>
<li><code>options</code> (<code>Object</code>):<ul>
<li><code>options.schema</code> (<code>Object</code>): Schema object with keys having field values based on <code>Types</code> expressions</li>
<li><code>options.initialize</code> (<code>Function</code>): Called when the Model is constructed</li>
<li><code>options.*</code> (<code>Function</code>): Custom methods</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>Model class.</p>
<h2 id="createcollection">createCollection</h2>
<blockquote>
<p>createCollection(options)</p>
</blockquote>
<h3 id="arguments">Arguments</h3>
<ol>
<li><code>options</code> (<code>Object</code>):<ul>
<li><code>options.model</code> (<code>Model</code>): Model class that this Collection is of</li>
<li><code>options.initialize</code> (<code>Function</code>): Called when the Collection is constructed</li>
<li><code>options.*</code> (<code>Function</code>): Custom methods</li>
</ul>
</li>
</ol>
<h3 id="returns">Returns</h3>
<p>Collection class.</p>
<h2 id="model">Model</h2>
<p>Next to the custom methods, Models also expose some built-in methods.</p>
<p>Some methods also support streaming the results with an Observable. Look for methods ending with <code>$</code>:</p>
<h3 id="model-getin">model.getIn</h3>
<blockquote>
<p>getIn(paths)</p>
<p>getIn$(paths)</p>
</blockquote>
<p>Returns the value in given path.</p>
<p>For example:</p>
<pre><code class="lang-js">const firstBookTitle = author.getIn([&#39;books&#39;, 0, &#39;title&#39;]);

// same as:
// author.books.at(0).title;
</code></pre>
<h3 id="model-get">model.get</h3>
<blockquote>
<p>get()</p>
<p>get(path)</p>
<p>get$(path)</p>
</blockquote>
<p>If no argument provided, then results self.</p>
<p>The <code>path</code> can either be key according to the model&#39;s schema, or a dot separated path targeting some nested child.</p>
<pre><code class="lang-js">person.get(&#39;books.0.title&#39;);

// same as:
// person.getIn([&#39;books&#39;, 0, &#39;title&#39;]);
</code></pre>
<h3 id="tojs">toJS</h3>
<blockquote>
<p>toJS()</p>
<p>toJS$()</p>
</blockquote>
<p>Returns a plain JavaScript object from all its properties, as well as nested Models and Collections.</p>
<h3 id="model-destroy">model.destroy</h3>
<blockquote>
<p>destroy()</p>
</blockquote>
<p>Destroys the model, and cleans up its watchers.</p>
<h2 id="collection">Collection</h2>
<p>The Collection instance tries to imitate the native <code>Array</code> as much as possible.</p>
<p>Most methods also support supporting streaming the results as they change. Look for methods ending with <code>$</code> in examples.</p>
<h3 id="collection-length">collection.length</h3>
<blockquote>
<p>length</p>
</blockquote>
<p>The lengh of the Collection.</p>
<pre><code class="lang-js">const length = collection.length;
</code></pre>
<h3 id="collection-at">collection.at</h3>
<blockquote>
<p>collection.at(n)</p>
<p>collection.at$(n)</p>
</blockquote>
<p>Returns the model at specific index</p>
<h3 id="collection-push">collection.push</h3>
<blockquote>
<p>collection.push(model)</p>
</blockquote>
<p>Pushes the model, and adds it to the end of the collection.</p>
<h3 id="collection-every">collection.every</h3>
<blockquote>
<p>every(iteratorFn)</p>
<p>every$(iteratorFn)</p>
</blockquote>
<p>Tests whether all models in the collection pass the test implemented by the provided function.</p>
<h3 id="collection-filter">collection.filter</h3>
<blockquote>
<p>filter(iteratorFn)</p>
<p>filter$(iteratorFn)</p>
</blockquote>
<p>Creates a new array with all models that pass the test implemented by the provided function.</p>
<h3 id="collection-find">collection.find</h3>
<blockquote>
<p>find(iteratorFn)</p>
<p>find$(iteratorFn)</p>
</blockquote>
<p>Returns a model in the collection, if a model in the array satisfies the provided testing function. Otherwise undefined is returned.</p>
<h3 id="collection-foreach">collection.forEach</h3>
<blockquote>
<p>forEach(iteratorFn)</p>
</blockquote>
<p>Executes provided function once per model in the collection.</p>
<h3 id="collection-includes">collection.includes</h3>
<blockquote>
<p>includes(model)</p>
<p>includes$(model)</p>
</blockquote>
<p>Determines whether colelction includes a certain model, returning true or false as appropriate.</p>
<h3 id="collection-indexof">collection.indexOf</h3>
<blockquote>
<p>indexOf(model)</p>
<p>indexOf$(model)</p>
</blockquote>
<p>Returns the first index at which a given model can be found in the collection, or -1 if it is not present.</p>
<h3 id="collection-map">collection.map</h3>
<blockquote>
<p>map(fn)</p>
<p>map$(fn)</p>
</blockquote>
<p>Creates a new array with the results of calling the provided function on every model in this collection.</p>
<h2 id="reduce">reduce</h2>
<blockquote>
<p>reduce(fn, initialValue)</p>
<p>reduce$(fn, initialValue)</p>
</blockquote>
<p>Applies the function against an accumulator and each model of the collection (from left-to-right) to reduce it to a single value.</p>
<h3 id="collection-some">collection.some</h3>
<blockquote>
<p>some(iteratorFn)</p>
<p>some$(iteratorFn)</p>
</blockquote>
<p>Tests whether some model in the collection passes the test implemented by the provided function.</p>
<h3 id="collection-pop">collection.pop</h3>
<blockquote>
<p>pop()</p>
</blockquote>
<p>Removes the last model from the collection and returns that model. This method changes the length of the collection.</p>
<h3 id="collection-shift">collection.shift</h3>
<blockquote>
<p>shift()</p>
</blockquote>
<p>Removes the first model from the collection and returns that model. This method changes the length of the collection.</p>
<h3 id="collection-unshift">collection.unshift</h3>
<blockquote>
<p>unshift(model)</p>
</blockquote>
<p>Adds one or more models to the beginning of the collection and returns the new length of the collection.</p>
<h3 id="collection-remove">collection.remove</h3>
<blockquote>
<p>remove(model)</p>
</blockquote>
<p>Removes model from the collection.</p>
<h3 id="collection-removefrom">collection.removeFrom</h3>
<blockquote>
<p>removeFrom(n)</p>
</blockquote>
<p>Removes model from the given n index.</p>
<h3 id="collection-first">collection.first</h3>
<blockquote>
<p>first()</p>
<p>first$()</p>
</blockquote>
<p>Gets the first model of the collection.</p>
<h3 id="collection-last">collection.last</h3>
<blockquote>
<p>last()</p>
<p>last$()</p>
</blockquote>
<p>Gets the last model of the collection.</p>
<h3 id="collection-take">collection.take</h3>
<blockquote>
<p>take(n = 1)</p>
<p>take$(n = 1)</p>
</blockquote>
<p>Creates a slice of array with n models taken from the beginning.</p>
<h3 id="collection-takeright">collection.takeRight</h3>
<blockquote>
<p>takeRight(n = 1)</p>
<p>takeRight$(n = 1)</p>
</blockquote>
<p>Creates a slice of array with n models taken from the end.</p>
<h3 id="collection-destroy">collection.destroy</h3>
<blockquote>
<p>destroy()</p>
</blockquote>
<p>Destroys the collection and its watchers.</p>
<h3 id="collection-tojs">collection.toJS</h3>
<blockquote>
<p>toJS()</p>
<p>toJS$()</p>
</blockquote>
<p>Converts the collection to a plain array, and also converting the models into plain objects recursively.</p>
<h3 id="collection-get">collection.get</h3>
<blockquote>
<p>get$()</p>
</blockquote>
<p>Returns an Observable of the collection, as it keeps on changing.</p>
<h2 id="ismodel">isModel</h2>
<blockquote>
<p>isModel(object)</p>
</blockquote>
<h3 id="arguments">Arguments</h3>
<ol>
<li><code>object</code> (<code>Object</code>): The argument to check against</li>
</ol>
<h3 id="returns">Returns</h3>
<p><code>Boolean</code>: True if the given object is a valid Model instance, false otherwise.</p>
<h2 id="iscollection">isCollection</h2>
<blockquote>
<p>isCollection(object)</p>
</blockquote>
<h3 id="arguments">Arguments</h3>
<ol>
<li><code>object</code> (<code>Object</code>): The argument to check against</li>
</ol>
<h3 id="returns">Returns</h3>
<p><code>Boolean</code>: True if the given object is a valid Collection instance, false otherwise.</p>
<h2 id="typeserror">TypesError</h2>
<blockquote>
<p>TypesError</p>
</blockquote>
<p>Thrown when Type checking has failed.</p>
<h2 id="methoderror">MethodError</h2>
<blockquote>
<p>MethodError</p>
</blockquote>
<p>Thrown when executing a custom method has resulted in an error.</p>
<h2 id="collectionerror">CollectionError</h2>
<blockquote>
<p>CollectionError</p>
</blockquote>
<p>Thrown when a Collection has experienced an error.</p>

          </div>
        </div>
      </div>
    </section>

    <footer class="footer">
  <div class="container">
    <div class="content has-text-centered">
      <p>
        <strong>FrintJS</strong> by <a href="https://travix.com">Travix International B.V.</a>.
        The source code is licensed under
        <a href="https://github.com/Travix-International/frint/blob/master/LICENSE">MIT</a>.
      </p>
      <p>
        <a class="icon" href="https://github.com/Travix-International/frint">
          <i class="fa fa-github"></i>
        </a>
      </p>
    </div>
  </div>
</footer>


    <style>
  .github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}
</style>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/themes/prism-solarizedlight.min.css" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" href="/css/site.css" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/prism.min.js"></script>
<script src="/js/site.js"></script>

<script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
  apiKey: '897a7279c47670a5c4b474ee84350387',
  indexName: 'frint.js',
  inputSelector: '#doc-search-text-box',
  debug: false // Set debug to true if you want to inspect the dropdown
});
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-93673400-1', 'auto');
  ga('send', 'pageview');
</script>

  </body>
</html>
